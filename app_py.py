# -*- coding: utf-8 -*-
"""app.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YA8VBBO7c9wuTZEOQ96TjYolc5V_DIFp
"""

pip install streamlit

import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import MinMaxScaler

# Load dataset
def load_data():
    # Simulated dataset for demonstration purposes
    data = {
        "date": pd.date_range(start="2023-01-01", periods=365, freq="D"),
        "brand": np.random.choice(["Amazon", "Tesla", "Apple"], size=365),
        "sentiment_score": np.random.uniform(-1, 1, size=365),
        "sentiment": np.random.choice(["Positive", "Negative", "Neutral"], size=365, p=[0.4, 0.3, 0.3])
    }
    return pd.DataFrame(data)

df = load_data()

# Streamlit App
def main():
    st.title("Twitter Sentiment Analysis and Forecast")

    # Sidebar filters
    st.sidebar.header("Filters")
    target_brand = st.sidebar.selectbox("Select a Brand", df['brand'].unique())
    date_range = st.sidebar.date_input("Select Date Range", [df['date'].min(), df['date'].max()])

    # Filter data
    filtered_data = df[(df['brand'] == target_brand) &
                       (df['date'] >= pd.to_datetime(date_range[0])) &
                       (df['date'] <= pd.to_datetime(date_range[1]))]

    if filtered_data.empty:
        st.error("No data available for the selected criteria. Please adjust your filters.")
    else:
        # Display filtered data
        st.subheader("Filtered Data")
        st.write(filtered_data)

        # Descriptive Statistics
        st.subheader("Descriptive Statistics")
        st.write(filtered_data.describe())

        # Sentiment Distribution Visualization
        st.subheader("Sentiment Distribution")
        sentiment_counts = filtered_data['sentiment'].value_counts()
        fig, ax = plt.subplots(figsize=(8, 5))
        sentiment_counts.plot(kind='bar', color=['green', 'red', 'blue'], ax=ax)
        ax.set_title("Sentiment Distribution")
        ax.set_xlabel("Sentiment")
        ax.set_ylabel("Tweet Count")
        st.pyplot(fig)

        # Sentiment Trend Over Time
        st.subheader("Sentiment Trend Over Time")
        sentiment_trend = filtered_data.groupby('date')['sentiment_score'].mean()
        fig, ax = plt.subplots(figsize=(10, 5))
        sns.lineplot(data=sentiment_trend, marker='o', ax=ax)
        ax.set_title(f"Average Sentiment for {target_brand}")
        ax.set_xlabel("Date")
        ax.set_ylabel("Average Sentiment Score")
        st.pyplot(fig)

        # Prepare data for Moving Average Forecasting
        scaler = MinMaxScaler()
        sentiment_series = filtered_data['sentiment_score'].values.reshape(-1, 1)
        scaled_data = scaler.fit_transform(sentiment_series)

        seq_length = 30
        if len(scaled_data) > seq_length:
            # Simple moving average forecasting
            forecast = np.mean(scaled_data[-seq_length:])
            forecast = scaler.inverse_transform([[forecast]])

            st.subheader("Sentiment Forecast")
            st.write(f"Predicted Sentiment Score for Next Day: {forecast[0][0]:.2f}")

            # Extend trend for visualization
            extended_trend = list(sentiment_trend) + [forecast[0][0]]
            future_dates = list(filtered_data['date']) + [filtered_data['date'].max() + pd.Timedelta(days=1)]

            fig, ax = plt.subplots(figsize=(10, 5))
            sns.lineplot(x=future_dates, y=extended_trend, marker='o', ax=ax)
            ax.set_title("Sentiment Trend with Forecast")
            ax.set_xlabel("Date")
            ax.set_ylabel("Average Sentiment Score")
            st.pyplot(fig)
        else:
            st.warning("Not enough data for modeling. Try expanding the date range.")

if __name__ == "__main__":
    main()